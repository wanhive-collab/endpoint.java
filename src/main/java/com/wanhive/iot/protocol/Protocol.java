/*
 * Protocol.java
 * 
 * Bare minimum wanhive protocol implementation
 * 
 * This program is part of Wanhive IoT Platform.
 * 
 * Apache-2.0 License
 * Copyright 2020 Wanhive Systems Private Limited
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * 
 */

package com.wanhive.iot.protocol;

import com.wanhive.iot.protocol.bean.IdentificationResponse;
import com.wanhive.iot.protocol.bean.MessageHeader;

/**
 * Bare minimum wanhive protocol implementation
 * 
 * @author amit
 *
 */
public class Protocol {
	protected static final String BADRESMSG = "Invalid response";
	protected static final String BADPARMMSG = "Invalid parameter";

	private short sequenceNumber;
	private byte session;

	/**
	 * Increments and returns the next sequence number
	 * 
	 * @return next sequence number
	 */
	public short nextSequenceNumber() {
		sequenceNumber += 1;
		if (sequenceNumber <= 0) {
			sequenceNumber = 1;
		}
		return sequenceNumber;
	}

	/**
	 * Resets the sequence number to given value
	 * 
	 * @param sequenceNumber value the sequence number will be set to
	 */
	public void setSequenceNumber(short sequenceNumber) {
		this.sequenceNumber = sequenceNumber;
	}

	/**
	 * Returns the current value of the sequence number
	 * 
	 * @return current sequence number
	 */
	public short getSequenceNumber() {
		return sequenceNumber;
	}

	/**
	 * Resets the session identifier to the given value
	 * 
	 * @param session desired value of session identifier
	 */
	public void setSession(byte session) {
		this.session = session;
	}

	/**
	 * Returns the currently set session identifier
	 * 
	 * @return value of the current session identifier
	 */
	public byte getSession() {
		return session;
	}

	/**
	 * Creates a new Protocol object which implements the bare minimum wanhive
	 * protocol
	 */
	public Protocol() {
		sequenceNumber = 0;
		session = 0;
	}

	// -----------------------------------------------------------------
	/**
	 * Creates a new message containing an identification request
	 * 
	 * @param id    identifier of the remote host
	 * @param uid   identifier of the client/user originating the request
	 * @param nonce public ephemeral value generated by the client/user
	 * @return a new Message object containing an identification request
	 * @throws Exception on bad parameter
	 */
	public Message createIdentificationRequest(long id, long uid, final byte[] nonce) throws Exception {
		if (nonce == null || nonce.length > Message.PAYLOAD_SIZE) {
			throw new Exception(BADPARMMSG);
		} else {
			Message message = new Message();
			message.prepareHeader(uid, id, (short) (Message.HEADER_SIZE + nonce.length), nextSequenceNumber(),
					getSession(), (byte) 0, (byte) 1, (byte) 127);
			message.setBlob(0, nonce);
			message.freeze();
			return message;
		}
	}

	/**
	 * Processes response to an identification request from a host
	 * 
	 * @param message response from a remote host
	 * @return an IdentificationResponse object containing a salt and ephemeral
	 *         value generated by the host
	 * @throws Exception on connection error, invalid response or request rejected
	 *                   by the host
	 */
	public IdentificationResponse processIdentificationResponse(Message message) throws Exception {
		MessageHeader header = message.getHeader();
		if (header.getCommand() != (byte) 0 || header.getQualifier() != (byte) 1 || header.getStatus() != (byte) 1) {
			throw new Exception(BADRESMSG);
		} else if (header.getLength() <= Message.HEADER_SIZE + 4) {
			throw new Exception(BADRESMSG);
		} else {
			short saltLength = message.getShort(0);
			short nonceLength = message.getShort(2);
			if (saltLength <= 0 || nonceLength <= 0 || (saltLength + nonceLength + 4) > Message.PAYLOAD_SIZE) {
				throw new Exception(BADRESMSG);
			}

			IdentificationResponse response = new IdentificationResponse();
			response.setSalt(message.getBlob(4, saltLength));
			response.setNonce(message.getBlob(4 + saltLength, nonceLength));
			return response;
		}
	}

	/**
	 * Creates a new message containing an authentication request
	 * 
	 * @param id    identifier of the remote host
	 * @param proof proof of client's identity
	 * @return a new Message object containing the authentication request
	 * @throws Exception on bad parameter
	 */
	public Message createAuthenticationRequest(long id, final byte[] proof) throws Exception {
		if (proof == null || proof.length == 0 || proof.length > Message.PAYLOAD_SIZE) {
			throw new Exception(BADPARMMSG);
		} else {
			Message message = new Message();
			message.prepareHeader(0, id, (short) (Message.HEADER_SIZE + proof.length), nextSequenceNumber(),
					getSession(), (byte) 0, (byte) 2, (byte) 127);
			message.setBlob(0, proof);
			message.freeze();
			return message;
		}
	}

	/**
	 * Processes response to an authentication request
	 * 
	 * @param message response from the remote host
	 * @return proof of remote host's identify for mutual authentication
	 * @throws Exception on connection error, invalid response or request rejected
	 *                   by the host
	 */
	public byte[] processAuthenticationResponse(Message message) throws Exception {
		MessageHeader header = message.getHeader();
		if (header.getCommand() != (byte) 0 || header.getQualifier() != (byte) 2 || header.getStatus() != (byte) 1) {
			throw new Exception(BADRESMSG);
		} else if (header.getLength() <= Message.HEADER_SIZE) {
			throw new Exception(BADRESMSG);
		} else {
			return message.getBlob(0, header.getLength() - Message.HEADER_SIZE);
		}
	}

	// -----------------------------------------------------------------
	/**
	 * Create a new message containing registration request
	 * 
	 * @param id  identifier of the remote host
	 * @param uid desired identifier of the client/user
	 * @param hc  the session key returned by the host
	 * @return a new Message object containing the registration request
	 */
	public Message createRegisterRequest(long id, long uid, byte[] hc) {
		short length = Message.HEADER_SIZE;
		Message message = new Message();
		if (hc != null) {
			message.setBlob(0, hc);
			length += hc.length;
		}

		message.prepareHeader(uid, id, length, nextSequenceNumber(), getSession(), (byte) 1, (byte) 0, (byte) 127);
		message.freeze();
		return message;
	}

	/**
	 * Processes response to a registration request
	 * 
	 * @param message response received from the remote host
	 * @return true if registration request was accepted by the remote host
	 * @throws Exception on connection error, invalid response or request rejected
	 *                   by the host
	 */
	public boolean processRegisterResponse(Message message) throws Exception {
		MessageHeader header = message.getHeader();
		if (header.getCommand() != (byte) 1 || header.getQualifier() != (byte) 0 || header.getStatus() != (byte) 1) {
			throw new Exception(BADRESMSG);
		} else if (header.getLength() != Message.HEADER_SIZE) {
			throw new Exception(BADRESMSG);
		} else {
			return true;
		}
	}

	/**
	 * Creates a new message requesting session key from the remote host
	 * 
	 * @param id identifier of the remote host
	 * @param hc 64-bit nonce generated by the client
	 * @return new Message object containing a session key request
	 */
	public Message createGetKeyRequest(long id, byte[] hc) {
		short length = Message.HEADER_SIZE;
		Message message = new Message();
		if (hc != null) {
			message.setBlob(0, hc);
			length += hc.length;
		}
		message.prepareHeader(0, id, length, nextSequenceNumber(), getSession(), (byte) 1, (byte) 1, (byte) 127);
		message.freeze();
		return message;
	}

	/**
	 * Processes response to a session key request
	 * 
	 * @param message response received from the remote host
	 * @return 64-byte session key returned by the host
	 * @throws Exception on connection error, invalid response or request rejected
	 *                   by the host
	 */
	public byte[] processGetKeyResponse(Message message) throws Exception {
		MessageHeader header = message.getHeader();
		if (header.getCommand() != (byte) 1 || header.getQualifier() != (byte) 1 || header.getStatus() != (byte) 1) {
			throw new Exception(BADRESMSG);
		} else if (header.getLength() <= Message.HEADER_SIZE) {
			throw new Exception(BADRESMSG);
		} else if (header.getLength() == (Message.HEADER_SIZE + 64)) {
			return message.getBlob(0, 64);
		} else if (header.getLength() == (Message.HEADER_SIZE + 128)) {
			return message.getBlob(64, 64);
		} else {
			throw new Exception(BADRESMSG);
		}
	}

	// -----------------------------------------------------------------
	/**
	 * Creates a new message containing request for a suitable wanhive host
	 * 
	 * @param id  identifier of the host acting as the bootstrapping node
	 * @param uid identifier of the client for which a host is being searched
	 * @return new Message object containing the request
	 */
	public Message createFindRootRequest(long id, long uid) {
		Message message = new Message();
		message.prepareHeader(0, id, (short) (Message.HEADER_SIZE + 8), nextSequenceNumber(), getSession(), (byte) 1,
				(byte) 2, (byte) 127);
		message.setLong(0, uid);
		message.freeze();
		return message;
	}

	/**
	 * Processes response to a bootstrapping request
	 * 
	 * @param message response from the host acting as the bootstrapping node
	 * @return identifier of the host the client must connect with
	 * @throws Exception on connection error, invalid response or request rejected
	 *                   by the host
	 */
	public long processFindRootResponse(Message message) throws Exception {
		MessageHeader header = message.getHeader();
		if (header.getCommand() != (byte) 1 || header.getQualifier() != (byte) 2 || header.getStatus() != (byte) 1) {
			throw new Exception(BADRESMSG);
		} else if (header.getLength() != (Message.HEADER_SIZE + 16)) {
			throw new Exception(BADRESMSG);
		} else {
			return message.getLong(8);
		}
	}

	// -----------------------------------------------------------------
	/**
	 * Creates a message containing data to be published to the given topic
	 * 
	 * @param id      identifier of the remote host
	 * @param topic   the topic identifier
	 * @param payload the message payload
	 * @return new Message object
	 */
	public Message createPublishRequest(long id, byte topic, byte[] payload) {
		Message message = new Message();
		message.prepareHeader(0, id, (short) (Message.HEADER_SIZE + (payload == null ? 0 : payload.length)),
				nextSequenceNumber(), topic, (byte) 2, (byte) 0, (byte) 127);
		message.setBlob(0, payload);
		message.freeze();
		return message;
	}

	/**
	 * Creates a subscription request to the given topic
	 * 
	 * @param id    identifier of the remote host
	 * @param topic identifier of the topic being subscribed to
	 * @return new Message object containing subscription request
	 */
	public Message createSubscribeRequest(long id, byte topic) {
		Message message = new Message();
		message.prepareHeader(0, id, (short) Message.HEADER_SIZE, nextSequenceNumber(), topic, (byte) 2, (byte) 1,
				(byte) 127);
		message.freeze();
		return message;
	}

	/**
	 * Processes response to a subscription request
	 * 
	 * @param message response received from the remote host
	 * @return true if the client subscribed to the desired topic
	 * @throws Exception on connection error, invalid response or request rejected
	 *                   by the host
	 */
	public boolean processSubscribeResponse(Message message) throws Exception {
		MessageHeader header = message.getHeader();
		if (header.getCommand() != (byte) 2 || header.getQualifier() != (byte) 1 || header.getStatus() != (byte) 1) {
			throw new Exception(BADRESMSG);
		} else if (header.getLength() != (Message.HEADER_SIZE)) {
			throw new Exception(BADRESMSG);
		} else {
			return true;
		}
	}

	/**
	 * Creates a request for deleting a subscription from the given topic
	 * 
	 * @param id    identifier of the remote host
	 * @param topic identifier of the topic the client wishes to unsubscribe from
	 * @return a new Message object containing the unsubscription request
	 */
	public Message createUnsubscribeRequest(long id, byte topic) {
		Message message = new Message();
		message.prepareHeader(0, id, (short) Message.HEADER_SIZE, nextSequenceNumber(), topic, (byte) 2, (byte) 2,
				(byte) 127);
		message.freeze();
		return message;
	}

	/**
	 * Processes response to a unsubscription request
	 * 
	 * @param message response from the remote host
	 * @return true if the request succeeded
	 * @throws Exception on connection error, invalid response or request rejected
	 *                   by the host
	 */
	public boolean processUnsubscribeResponse(Message message) throws Exception {
		MessageHeader header = message.getHeader();
		if (header.getCommand() != (byte) 2 || header.getQualifier() != (byte) 2 || header.getStatus() != (byte) 1) {
			throw new Exception(BADRESMSG);
		} else if (header.getLength() != (Message.HEADER_SIZE)) {
			throw new Exception(BADRESMSG);
		} else {
			return true;
		}
	}
}
