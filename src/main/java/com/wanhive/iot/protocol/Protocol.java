/*
 * Protocol.java
 * 
 * The wanhive protocol implementation
 * 
 * This program is part of Wanhive IoT Platform.
 * 
 * Apache-2.0 License
 * Copyright 2020 Wanhive Systems Private Limited
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * 
 */

package com.wanhive.iot.protocol;

import com.wanhive.iot.protocol.bean.IdentificationResponse;
import com.wanhive.iot.protocol.bean.MessageContext;

/**
 * The wanhive protocol implementation
 * 
 * @author amit
 *
 */
public class Protocol {
	private static final String BADRESMSG = "Invalid response";
	private static final String BADPARMMSG = "Invalid request";

	private short sequenceNumber;
	private byte session;

	/**
	 * Checks message's context
	 * 
	 * @param message   The message to check
	 * @param command   The expected command classifier
	 * @param qualifier The expected command qualifier
	 * @return true if the message matched the context, false otherwise
	 */
	protected static boolean checkContext(Message message, byte command, byte qualifier) {
		return (message.getCommand() == command && message.getQualifier() == qualifier);
	}

	/**
	 * Checks message's context
	 * 
	 * @param message   The message to check
	 * @param command   The expected command classifier
	 * @param qualifier The expected command qualifier
	 * @param status    The expected status code
	 * @return true if the message matched the context, false otherwise
	 */
	protected static boolean checkContext(Message message, byte command, byte qualifier, byte status) {
		return checkContext(message, command, qualifier) && (message.getStatus() == status);
	}

	/**
	 * Checks message's context
	 * 
	 * @param message The message to check
	 * @param ctx     The MessageContext object
	 * @return true if the message matched the context, false otherwise
	 */
	protected static boolean checkContext(Message message, MessageContext ctx) {
		return checkContext(message, ctx.getCommand(), ctx.getQualifier(), ctx.getStatus());
	}

	/**
	 * Increments and returns the next sequence number
	 * 
	 * @return next sequence number
	 */
	public short nextSequenceNumber() {
		sequenceNumber += 1;
		if (sequenceNumber <= 0) {
			sequenceNumber = 1;
		}
		return sequenceNumber;
	}

	/**
	 * Sets the sequence number to the given value
	 * 
	 * @param sequenceNumber The sequence number counter will be set to this value
	 */
	public void setSequenceNumber(short sequenceNumber) {
		this.sequenceNumber = sequenceNumber;
	}

	/**
	 * Returns the current value of the sequence number counter
	 * 
	 * @return current sequence number
	 */
	public short getSequenceNumber() {
		return sequenceNumber;
	}

	/**
	 * Resets the session identifier to the given value
	 * 
	 * @param session The session identifier will be set to this value
	 */
	public void setSession(byte session) {
		this.session = session;
	}

	/**
	 * Returns the currently active session identifier
	 * 
	 * @return The current session identifier value
	 */
	public byte getSession() {
		return session;
	}

	/**
	 * The default constructor
	 */
	public Protocol() {
		sequenceNumber = 0;
		session = 0;
	}

	// -----------------------------------------------------------------
	/**
	 * Creates an identification request
	 * 
	 * @param id    Remote host's identifier
	 * @param uid   Local client's identifier
	 * @param nonce The public ephemeral value generated by the client/user
	 * @return An identification request
	 * @throws Exception Invalid parameter(s)
	 */
	public Message createIdentificationRequest(long id, long uid, final byte[] nonce) throws Exception {
		if (nonce == null || nonce.length > Message.PAYLOAD_SIZE) {
			throw new Exception(BADPARMMSG);
		} else {
			Message message = new Message();
			message.prepareHeader(uid, id, (short) (Message.HEADER_SIZE + nonce.length), nextSequenceNumber(),
					getSession(), RequestContext.IDENTIFY);
			message.setBlob(0, nonce);
			return message;
		}
	}

	/**
	 * Processes an identification response
	 * 
	 * @param message The identification response
	 * @return An IdentificationResponse object
	 * @throws Exception Request denied or invalid response
	 */
	public IdentificationResponse processIdentificationResponse(Message message) throws Exception {
		if (!checkContext(message, ResponseContext.IDENTIFY)) {
			throw new Exception(BADRESMSG);
		} else if (message.getLength() <= Message.HEADER_SIZE + 4) {
			throw new Exception(BADRESMSG);
		} else {
			short saltLength = message.getShort(0);
			short nonceLength = message.getShort(2);
			if (saltLength <= 0 || nonceLength <= 0 || (saltLength + nonceLength + 4) > Message.PAYLOAD_SIZE) {
				throw new Exception(BADRESMSG);
			}

			IdentificationResponse response = new IdentificationResponse();
			response.setSalt(message.getBlob(4, saltLength));
			response.setNonce(message.getBlob(4 + saltLength, nonceLength));
			return response;
		}
	}

	/**
	 * Creates an authentication request
	 * 
	 * @param id    Remote host's identifier
	 * @param proof The proof of the local client's identity
	 * @return An authentication request
	 * @throws Exception Invalid parameter(s)
	 */
	public Message createAuthenticationRequest(long id, final byte[] proof) throws Exception {
		if (proof == null || proof.length == 0 || proof.length > Message.PAYLOAD_SIZE) {
			throw new Exception(BADPARMMSG);
		} else {
			Message message = new Message();
			message.prepareHeader(0, id, (short) (Message.HEADER_SIZE + proof.length), nextSequenceNumber(),
					getSession(), RequestContext.AUTHENTICATE);
			message.setBlob(0, proof);
			return message;
		}
	}

	/**
	 * Processes an authentication response
	 * 
	 * @param message The response from the remote host
	 * @return The proof of remote host's identity
	 * @throws Exception Request denied or invalid response
	 */
	public byte[] processAuthenticationResponse(Message message) throws Exception {
		short msgLen = message.getLength();
		if (!checkContext(message, ResponseContext.AUTHENTICATE)) {
			throw new Exception(BADRESMSG);
		} else if (msgLen <= Message.HEADER_SIZE) {
			throw new Exception(BADRESMSG);
		} else {
			return message.getBlob(0, msgLen - Message.HEADER_SIZE);
		}
	}

	// -----------------------------------------------------------------
	/**
	 * Creates a registration request
	 * 
	 * @param id  Remote host's identifier
	 * @param uid desired identifier of the local client
	 * @param hc  The session key
	 * @return A registration request
	 */
	public Message createRegisterRequest(long id, long uid, byte[] hc) {
		short length = Message.HEADER_SIZE;
		Message message = new Message();
		if (hc != null) {
			message.setBlob(0, hc);
			length += hc.length;
		}
		message.prepareHeader(uid, id, length, nextSequenceNumber(), getSession(), RequestContext.REGISTER);
		return message;
	}

	/**
	 * Processes a registration response
	 * 
	 * @param message The registration response
	 * @return true if registration request was accepted by the remote host
	 * @throws Exception Request denied or invalid response
	 */
	public boolean processRegisterResponse(Message message) throws Exception {
		if (!checkContext(message, ResponseContext.REGISTER)) {
			throw new Exception(BADRESMSG);
		} else if (message.getLength() != Message.HEADER_SIZE) {
			throw new Exception(BADRESMSG);
		} else {
			return true;
		}
	}

	/**
	 * Creates a Session Key request
	 * 
	 * @param id The identifier of the remote host
	 * @param hc 64-bit nonce generated by the client
	 * @return A session key request
	 */
	public Message createGetKeyRequest(long id, byte[] hc) {
		short length = Message.HEADER_SIZE;
		Message message = new Message();
		if (hc != null) {
			message.setBlob(0, hc);
			length += hc.length;
		}
		message.prepareHeader(0, id, length, nextSequenceNumber(), getSession(), RequestContext.GETKEY);
		return message;
	}

	/**
	 * Processes session key response
	 * 
	 * @param message The response received from the remote host
	 * @return 64-byte session key returned by the host
	 * @throws Exception Request denied or invalid response
	 */
	public byte[] processGetKeyResponse(Message message) throws Exception {
		short msgLen = message.getLength();
		if (!checkContext(message, ResponseContext.GETKEY)) {
			throw new Exception(BADRESMSG);
		} else if (msgLen <= Message.HEADER_SIZE) {
			throw new Exception(BADRESMSG);
		} else if (msgLen == (Message.HEADER_SIZE + 64)) {
			return message.getBlob(0, 64);
		} else if (msgLen == (Message.HEADER_SIZE + 128)) {
			return message.getBlob(64, 64);
		} else {
			throw new Exception(BADRESMSG);
		}
	}

	// -----------------------------------------------------------------
	/**
	 * Creates a bootstrap request
	 * 
	 * @param id  The identifier of the bootstrapping node
	 * @param uid The client identifier
	 * @return A new Message object containing the request
	 */
	public Message createFindRootRequest(long id, long uid) {
		Message message = new Message();
		message.prepareHeader(0, id, (short) (Message.HEADER_SIZE + 8), nextSequenceNumber(), getSession(),
				RequestContext.FINDROOT);
		message.setLong(0, uid);
		return message;
	}

	/**
	 * Processes the bootstrap response
	 * 
	 * @param message The bootstrap response
	 * @return The identifier of the root host
	 * @throws Exception Request denied or invalid response
	 */
	public long processFindRootResponse(Message message) throws Exception {
		if (!checkContext(message, ResponseContext.FINDROOT)) {
			throw new Exception(BADRESMSG);
		} else if (message.getLength() != (Message.HEADER_SIZE + 16)) {
			throw new Exception(BADRESMSG);
		} else {
			return message.getLong(8);
		}
	}

	// -----------------------------------------------------------------
	/**
	 * Creates a publish request
	 * 
	 * @param id      The identifier of the remote host
	 * @param topic   The topic identifier
	 * @param payload The data to be published to the given topic
	 * @return A new publish request
	 */
	public Message createPublishRequest(long id, byte topic, byte[] payload) {
		Message message = new Message();
		message.prepareHeader(0, id, (short) (Message.HEADER_SIZE + (payload == null ? 0 : payload.length)),
				nextSequenceNumber(), topic, RequestContext.PUBLISH);
		message.setBlob(0, payload);
		return message;
	}

	/**
	 * Creates a subscription request
	 * 
	 * @param id    The identifier of the remote host
	 * @param topic The topic identifier
	 * @return A new subscription request
	 */
	public Message createSubscribeRequest(long id, byte topic) {
		Message message = new Message();
		message.prepareHeader(0, id, (short) Message.HEADER_SIZE, nextSequenceNumber(), topic,
				RequestContext.SUBSCRIBE);
		return message;
	}

	/**
	 * Processes the response to a subscription request
	 * 
	 * @param message The response to a subscription request
	 * @return true if the subscription request succeeded
	 * @throws Exception Request denied or invalid response
	 */
	public boolean processSubscribeResponse(Message message) throws Exception {
		if (!checkContext(message, ResponseContext.SUBSCRIBE)) {
			throw new Exception(BADRESMSG);
		} else if (message.getLength() != (Message.HEADER_SIZE)) {
			throw new Exception(BADRESMSG);
		} else {
			return true;
		}
	}

	/**
	 * Creates an unsubscription request
	 * 
	 * @param id    The identifier of the remote host
	 * @param topic The topic to unsubscribe from
	 * @return A new unsubscription request
	 */
	public Message createUnsubscribeRequest(long id, byte topic) {
		Message message = new Message();
		message.prepareHeader(0, id, (short) Message.HEADER_SIZE, nextSequenceNumber(), topic,
				RequestContext.UNSUBSCRIBE);
		return message;
	}

	/**
	 * Processes the response to an unsubscription request
	 * 
	 * @param message The response to an unsubscription request
	 * @return true if the request succeeded
	 * @throws Exception Request denied or invalid response
	 */
	public boolean processUnsubscribeResponse(Message message) throws Exception {
		if (!checkContext(message, ResponseContext.UNSUBSCRIBE)) {
			throw new Exception(BADRESMSG);
		} else if (message.getLength() != (Message.HEADER_SIZE)) {
			throw new Exception(BADRESMSG);
		} else {
			return true;
		}
	}
}
